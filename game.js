//File that drives the logic behind the game itself
//instantiating values that will be used in the game
let currentDrawing = 0;
//this list of topics was generated by a generative AI
const topics = [
    "Apple", "Banana", "Car", "Dog", "Elephant", "Flower", "Giraffe", "House", "Ice cream", "Jellyfish",
    "Kangaroo", "Lion", "Mountain", "Nest", "Owl", "Penguin", "Queen", "Robot", "Snake", "Tree",
    "Umbrella", "Violin", "Whale", "Xylophone", "Yacht", "Zebra", "Beach", "Cityscape", "Desert",
    "Eagle", "Forest", "Guitar", "Harbor", "Island", "Jungle", "Kite", "Lighthouse", "Mushroom", "Night",
    "Ocean", "Palm Tree", "Quilt", "River", "Sunset", "Tulip", "Unicorn", "Volcano", "Waterfall", "X-ray",
    "Yellow", "Zoo", "Acorn", "Ballet Dancer", "Cowboy", "Dragon", "Elf", "Firefighter", "Ghost", "Helmet",
    "Ink", "Jester", "Knight", "Lamp", "Magnet", "Noodle", "Orchestra", "Pirate", "Quiver", "Racquet",
    "Scarecrow", "Tornado", "Urchin", "Van", "Witch", "Explorer", "Yoga", "Zen Garden", "Actor", "Bridge",
    "Carnival", "Dumpling", "Empire", "Fountain", "Gnome", "Hammock", "Igloo", "Jacket", "Key", "Lemon",
    "Mirror", "Nebula", "Oboe", "Peacock", "Quartz", "Rodeo", "Sphinx", "Teacup", "Ukulele", "Vase",
    "Windmill", "Xenon", "Yard", "Zeppelin", "Arch", "Bucket", "Cupcake", "Dinosaur", "Easel", "Feather",
    "Globe", "Helmet", "Iris", "JalapeÃ±o", "Koala", "Lobster", "Marshmallow", "Narwhal", "Octopus", "Paddle",
    "Quiche", "Rose", "Spaceship", "Tiger", "Umbrella", "Visor", "Wagon", "Xylophone", "Yogurt", "Zucchini",
    "Accordion", "Bonsai", "Cactus", "Drum", "Eggplant", "Flamingo", "Gazebo", "Harp", "Iceberg", "Jackal",
    "Kiwi", "Lemur", "Mango", "Nest", "Ostrich", "Parrot", "Quail", "Raspberry", "Strawberry", "Teapot",
    "Umpire", "Vanilla", "Waffle", "Xerus", "Yucca", "Zither", "Astrolabe", "Bamboo", "Chameleon", "Dove",
    "Egg", "Fig", "Gargoyle", "Hydrant", "Impala", "Jug", "Kiln", "Lilac", "Moose", "Neptune", "Olive",
    "Pumpkin", "Quill", "Rabbit", "Salamander", "Tomato", "Udon", "Violet", "Walrus", "Xenopus", "Yak",
    "Zodiac", "Albatross", "Boomerang", "Cyclone", "Daffodil", "Engine", "Frog", "Grasshopper", "Hibiscus",
    "Ivy", "Jigsaw", "Kettle", "Lynx", "Mandrill", "Nutcracker", "Ocelot", "Padlock", "Quasar", "Rhinoceros",
    "Seahorse", "Turnip", "Urchin", "Vent", "Wallaby", "X-ray Fish", "Yam", "Zipline", "Angelfish", "Bobcat",
    "Croissant", "Dahlia", "Emu", "Ferris Wheel", "Gecko", "Honeycomb", "Icicle", "Jackrabbit", "Komodo Dragon",
    "Lava", "Macaw", "Nectarine", "Opal", "Panda", "Quokka", "Reindeer", "Squirrel", "Truffle", "Uakari"];
//getting drawing number
const numberOfDrawings = parseInt(localStorage.getItem("drawingNumber"));
let game_clock = setInterval(tick, 1000);
//initiates the game
function start_drawing() {
    game_clock = setInterval(tick, 1000);
    //we set current drawing to zero just in case this isnt our first time playing in this instance
    currentDrawing = 0;
    next_drawing();
}
//this function handles the logic associated with switching the drawing and topic to the next drawing and topic, creating new drawings when needed, and saving them.
function next_drawing() {
    //if we aren't entering for the first time we save
    if  (currentDrawing !== 0) {
        save_drawing(currentDrawing);
    }

    currentDrawing++;
    //set the topic to the topic assigned to the current drawing
    document.getElementById('topic').innerHTML = localStorage.getItem("topic" + currentDrawing)

    //if we've reached the limit of drawings we stop drawing
    if (currentDrawing > numberOfDrawings) {
        done_drawing();
    }
    //if we cant load the current drawing index we assume it doesn't exist yet and make a new one
    if (!load_drawing()) {
        console.log("no drawing, making new one " + currentDrawing);
        fillCanvas();
    }

}
//stop the clock and reset the index, send user to repeat page
function done_drawing() {
    clearInterval(game_clock);
    currentDrawing = 0;
    window.location.href = "RepeatPage.html";
}
//function for loading drawing
function load_drawing() {
    //getting drawing from local storage using naming conventions
    const curURL = localStorage.getItem('drawing' + currentDrawing);
    //make new image, wait for it to load, and then clear the canvas and draw the image
    if (curURL) {
        const img = new Image();
        img.onload = function () {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
        };
        //sets image display to our retrieved image
        img.src = curURL;
        return true;
        //exception for no drawing found
    } else {
        console.error("Can\'t load drawing");
        return false;
    }

}
//function to save the current drawing
function save_drawing() {
    //converts canvas to data url and saves it in new const
    const picURL = canvas.toDataURL('image/png');
    //stores the drawing in local storage using proper naming convention so we can find it later
    localStorage.setItem('drawing' + currentDrawing, picURL);
    //clears canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}
//function to randomly select topics
function getTopics() {
    //blacklist so we don't get the same topics
    let blacklist = [];
    //uses Math.random to find random entry in the topics list and adds it to the selected topics assuming it isn't blacklisted, then blacklists
    for (let i = 1; i < numberOfDrawings + 1; i++) {
        let randomSelection;
        do {
            randomSelection = Math.floor(Math.random() * topics.length);
        } while (blacklist.includes(randomSelection));

         localStorage.setItem("topic" + i, topics[randomSelection]);
        blacklist.push(randomSelection);
    }
}











